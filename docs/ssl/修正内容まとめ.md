# タスク4の修正内容まとめ

## 修正の概要

データセットに**ノイズを意図的に付与する処理**を追加しました。

---

## 主な変更点

### 1. `task/dataset.py`の修正

#### 変更前
- `y`（ヒステリシスのデータ）からノイズ区間を取得しようとしていた
- ノイズを付与していなかった

#### 変更後
- **ノイズを意図的に付与**する処理を追加
- ランダムに1区間を選んでノイズを付与
- ノイズを付与した区間のインデックスを正解ラベルとして返す

#### 具体的な変更

1. **noiseモジュールのインポート追加**
```python
from noise.add_noise import add_noise_to_interval
```

2. **`__init__`メソッドの修正**
- `use_noise_labels`パラメータを削除
- `noise_type`と`noise_level`パラメータを追加

3. **`__getitem__`メソッドの修正**
```python
# 1. 元のPSDデータを読み込む（ノイズなし）
base_psd = self.x[idx]

# 2. ランダムに1つの区間を選ぶ
noise_interval = np.random.randint(0, self.num_intervals)

# 3. ノイズを付与
noisy_psd_tensor, start_idx, end_idx = add_noise_to_interval(
    base_psd_tensor,
    noise_interval,
    noise_type=self.noise_type,
    noise_level=self.noise_level,
    num_intervals=self.num_intervals
)

# 4. マスクを作成（ノイズとは別、学習用）
masked_interval_indices = np.random.choice(...)

# 5. 返り値
return {
    'input': ノイズ付与 + マスクされたデータ,
    'target': ノイズ付与されたデータ（マスクなし）,
    'mask': マスク位置,
    'noise_interval': ノイズを付与した区間のインデックス（正解ラベル）
}
```

---

### 2. `task/train.py`の修正

#### 変更点
- `use_noise_labels`パラメータを削除
- `noise_type`と`noise_level`パラメータを追加
- データセット作成時にノイズタイプとレベルを指定

---

### 3. `task4_colab.ipynb`の修正

#### 変更点
- 学習時の`train_task4`呼び出しに`noise_type`と`noise_level`を追加
- 評価時の`Task4Dataset`作成に`noise_type`と`noise_level`を追加

---

### 4. `noise`モジュールの追加

- `temp_repo/noise/`から`noise/`にコピー
- 3種類のノイズパターンを使用可能

---

## データの流れ（修正後）

### 学習時

```
1. 元のPSDデータを読み込む（ノイズなし）
   base_psd = data['x'][idx]
   
2. ランダムに1区間を選ぶ
   noise_interval = 15（例）
   
3. その区間にノイズを付与
   noisy_psd = add_noise_to_interval(base_psd, noise_interval=15, ...)
   → [区間1, ..., 区間15（ノイズあり）, ..., 区間30]
   
4. ランダムに15%の区間をマスク（ノイズとは別）
   masked_intervals = [5, 12, 20]（例）
   → [区間1, ..., [MASK], ..., 区間15（ノイズあり）, ..., [MASK], ..., 区間30]
   
5. 返り値
   - input: ノイズ付与 + マスクされたデータ
   - target: ノイズ付与されたデータ（マスクなし）
   - mask: マスク位置
   - noise_interval: 15（正解ラベル）
```

### 評価時

```
1. テストデータにノイズを付与（学習時と同じ方法）
   noise_interval = 20（例、正解ラベルとして記録）
   
2. モデルでアテンションウェイトを取得
   attention_weights = model(...)
   
3. ノイズ区間を予測
   predicted_interval = argmin(アテンションウェイト) = 20
   
4. 正解と予測を比較
   accuracy = (predicted_interval == noise_interval)
```

---

## 重要なポイント

### ノイズの付与タイミング

- **データローダー内で毎回付与**: `__getitem__`で毎回ランダムにノイズを付与
- **同じデータでも異なるノイズ**: 毎回ランダムなので、同じデータでも異なるノイズが付与される
- **正解ラベルは毎回記録**: ノイズを付与した区間のインデックスを正解ラベルとして返す

### マスクとノイズの違い

- **マスク**: 学習用（ランダムに15%の区間を0で置き換え）
- **ノイズ**: 検知対象（1区間に人工ノイズを付与）

### 評価の一貫性

- 学習時も評価時も、同じ方法でノイズを付与
- 同じノイズタイプとレベルを使用
- 正解ラベル（ノイズ区間のインデックス）を使って評価

---

## 使用方法

### データセットの作成

```python
from task.dataset import Task4Dataset

dataset = Task4Dataset(
    pickle_path="data_lowF_noise.pickle",
    num_intervals=30,
    noise_type='frequency_band',  # または 'localized_spike', 'amplitude_dependent'
    noise_level=0.3,
)
```

### 学習の実行

```python
from task.train import train_task4

model, train_losses, val_losses, best_val_loss = train_task4(
    pickle_path="data_lowF_noise.pickle",
    noise_type='frequency_band',
    noise_level=0.3,
    ...
)
```

---

## まとめ

✅ **ノイズを意図的に付与する処理を追加**
✅ **ノイズを付与した区間のインデックスを正解ラベルとして返す**
✅ **ベースラインと同じ方法でノイズを付与**
✅ **評価コードは統一（同じラベルを使用）**

これで、タスク4でもノイズ検知の評価が正しく行えるようになりました！

